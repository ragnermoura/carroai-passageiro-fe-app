{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport { keyExtractor as defaultKeyExtractor } from './VirtualizeUtils';\nimport invariant from 'invariant';\nvar ListMetricsAggregator = function () {\n  function ListMetricsAggregator() {\n    _classCallCheck(this, ListMetricsAggregator);\n    this._averageCellLength = 0;\n    this._cellMetrics = new Map();\n    this._highestMeasuredCellIndex = 0;\n    this._measuredCellsLength = 0;\n    this._measuredCellsCount = 0;\n    this._orientation = {\n      horizontal: false,\n      rtl: false\n    };\n  }\n  return _createClass(ListMetricsAggregator, [{\n    key: \"notifyCellLayout\",\n    value: function notifyCellLayout(_ref) {\n      var cellIndex = _ref.cellIndex,\n        cellKey = _ref.cellKey,\n        orientation = _ref.orientation,\n        layout = _ref.layout;\n      this._invalidateIfOrientationChanged(orientation);\n      var next = {\n        index: cellIndex,\n        length: this._selectLength(layout),\n        isMounted: true,\n        offset: this.flowRelativeOffset(layout)\n      };\n      var curr = this._cellMetrics.get(cellKey);\n      if (!curr || next.offset !== curr.offset || next.length !== curr.length) {\n        if (curr) {\n          var dLength = next.length - curr.length;\n          this._measuredCellsLength += dLength;\n        } else {\n          this._measuredCellsLength += next.length;\n          this._measuredCellsCount += 1;\n        }\n        this._averageCellLength = this._measuredCellsLength / this._measuredCellsCount;\n        this._cellMetrics.set(cellKey, next);\n        this._highestMeasuredCellIndex = Math.max(this._highestMeasuredCellIndex, cellIndex);\n        return true;\n      } else {\n        curr.isMounted = true;\n        return false;\n      }\n    }\n  }, {\n    key: \"notifyCellUnmounted\",\n    value: function notifyCellUnmounted(cellKey) {\n      var curr = this._cellMetrics.get(cellKey);\n      if (curr) {\n        curr.isMounted = false;\n      }\n    }\n  }, {\n    key: \"notifyListContentLayout\",\n    value: function notifyListContentLayout(_ref2) {\n      var orientation = _ref2.orientation,\n        layout = _ref2.layout;\n      this._invalidateIfOrientationChanged(orientation);\n      this._contentLength = this._selectLength(layout);\n    }\n  }, {\n    key: \"getAverageCellLength\",\n    value: function getAverageCellLength() {\n      return this._averageCellLength;\n    }\n  }, {\n    key: \"getHighestMeasuredCellIndex\",\n    value: function getHighestMeasuredCellIndex() {\n      return this._highestMeasuredCellIndex;\n    }\n  }, {\n    key: \"getCellMetricsApprox\",\n    value: function getCellMetricsApprox(index, props) {\n      var frame = this.getCellMetrics(index, props);\n      if (frame && frame.index === index) {\n        return frame;\n      } else {\n        var data = props.data,\n          getItemCount = props.getItemCount;\n        invariant(index >= 0 && index < getItemCount(data), 'Tried to get frame for out of range index ' + index);\n        return {\n          length: this._averageCellLength,\n          offset: this._averageCellLength * index,\n          index: index,\n          isMounted: false\n        };\n      }\n    }\n  }, {\n    key: \"getCellMetrics\",\n    value: function getCellMetrics(index, props) {\n      var _props$keyExtractor;\n      var data = props.data,\n        getItem = props.getItem,\n        getItemCount = props.getItemCount,\n        getItemLayout = props.getItemLayout;\n      invariant(index >= 0 && index < getItemCount(data), 'Tried to get metrics for out of range cell index ' + index);\n      var keyExtractor = (_props$keyExtractor = props.keyExtractor) != null ? _props$keyExtractor : defaultKeyExtractor;\n      var frame = this._cellMetrics.get(keyExtractor(getItem(data, index), index));\n      if (frame && frame.index === index) {\n        return frame;\n      }\n      if (getItemLayout) {\n        var _getItemLayout = getItemLayout(data, index),\n          length = _getItemLayout.length,\n          offset = _getItemLayout.offset;\n        return {\n          index: index,\n          length: length,\n          offset: offset,\n          isMounted: true\n        };\n      }\n      return null;\n    }\n  }, {\n    key: \"getCellOffsetApprox\",\n    value: function getCellOffsetApprox(index, props) {\n      if (Number.isInteger(index)) {\n        return this.getCellMetricsApprox(index, props).offset;\n      } else {\n        var frameMetrics = this.getCellMetricsApprox(Math.floor(index), props);\n        var remainder = index - Math.floor(index);\n        return frameMetrics.offset + remainder * frameMetrics.length;\n      }\n    }\n  }, {\n    key: \"getContentLength\",\n    value: function getContentLength() {\n      var _this$_contentLength;\n      return (_this$_contentLength = this._contentLength) != null ? _this$_contentLength : 0;\n    }\n  }, {\n    key: \"hasContentLength\",\n    value: function hasContentLength() {\n      return this._contentLength != null;\n    }\n  }, {\n    key: \"flowRelativeOffset\",\n    value: function flowRelativeOffset(layout, referenceContentLength) {\n      var _this$_orientation = this._orientation,\n        horizontal = _this$_orientation.horizontal,\n        rtl = _this$_orientation.rtl;\n      if (horizontal && rtl) {\n        var contentLength = referenceContentLength != null ? referenceContentLength : this._contentLength;\n        invariant(contentLength != null, 'ListMetricsAggregator must be notified of list content layout before resolving offsets');\n        return contentLength - (this._selectOffset(layout) + this._selectLength(layout));\n      } else {\n        return this._selectOffset(layout);\n      }\n    }\n  }, {\n    key: \"cartesianOffset\",\n    value: function cartesianOffset(flowRelativeOffset) {\n      var _this$_orientation2 = this._orientation,\n        horizontal = _this$_orientation2.horizontal,\n        rtl = _this$_orientation2.rtl;\n      if (horizontal && rtl) {\n        invariant(this._contentLength != null, 'ListMetricsAggregator must be notified of list content layout before resolving offsets');\n        return this._contentLength - flowRelativeOffset;\n      } else {\n        return flowRelativeOffset;\n      }\n    }\n  }, {\n    key: \"_invalidateIfOrientationChanged\",\n    value: function _invalidateIfOrientationChanged(orientation) {\n      if (orientation.rtl !== this._orientation.rtl) {\n        this._cellMetrics.clear();\n      }\n      if (orientation.horizontal !== this._orientation.horizontal) {\n        this._averageCellLength = 0;\n        this._highestMeasuredCellIndex = 0;\n        this._measuredCellsLength = 0;\n        this._measuredCellsCount = 0;\n      }\n      this._orientation = orientation;\n    }\n  }, {\n    key: \"_selectLength\",\n    value: function _selectLength(_ref3) {\n      var width = _ref3.width,\n        height = _ref3.height;\n      return this._orientation.horizontal ? width : height;\n    }\n  }, {\n    key: \"_selectOffset\",\n    value: function _selectOffset(_ref4) {\n      var x = _ref4.x,\n        y = _ref4.y;\n      return this._orientation.horizontal ? x : y;\n    }\n  }]);\n}();\nexport { ListMetricsAggregator as default };","map":{"version":3,"names":["keyExtractor","defaultKeyExtractor","invariant","ListMetricsAggregator","_classCallCheck","_averageCellLength","_cellMetrics","Map","_highestMeasuredCellIndex","_measuredCellsLength","_measuredCellsCount","_orientation","horizontal","rtl","_createClass","key","value","notifyCellLayout","_ref","cellIndex","cellKey","orientation","layout","_invalidateIfOrientationChanged","next","index","length","_selectLength","isMounted","offset","flowRelativeOffset","curr","get","dLength","set","Math","max","notifyCellUnmounted","notifyListContentLayout","_ref2","_contentLength","getAverageCellLength","getHighestMeasuredCellIndex","getCellMetricsApprox","props","frame","getCellMetrics","data","getItemCount","_props$keyExtractor","getItem","getItemLayout","_getItemLayout","getCellOffsetApprox","Number","isInteger","frameMetrics","floor","remainder","getContentLength","_this$_contentLength","hasContentLength","referenceContentLength","_this$_orientation","contentLength","_selectOffset","cartesianOffset","_this$_orientation2","clear","_ref3","width","height","_ref4","x","y","default"],"sources":["C:/Users/dudug/OneDrive/Área de Trabalho/projetos-reactnative/carroai-passageiro-fe-app/node_modules/@react-native/virtualized-lists/Lists/ListMetricsAggregator.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow strict-local\n * @format\n */\n\nimport type {Layout} from 'react-native/Libraries/Types/CoreEventTypes';\nimport type {Props as VirtualizedListProps} from './VirtualizedListProps';\nimport {keyExtractor as defaultKeyExtractor} from './VirtualizeUtils';\n\nimport invariant from 'invariant';\n\nexport type CellMetrics = {\n  /**\n   * Index of the item in the list\n   */\n  index: number,\n  /**\n   * Length of the cell along the scrolling axis\n   */\n  length: number,\n  /**\n   * Distance between this cell and the start of the list along the scrolling\n   * axis\n   */\n  offset: number,\n  /**\n   * Whether the cell is last known to be mounted\n   */\n  isMounted: boolean,\n};\n\n// TODO: `inverted` can be incorporated here if it is moved to an order\n// based implementation instead of transform.\nexport type ListOrientation = {\n  horizontal: boolean,\n  rtl: boolean,\n};\n\n/**\n * Subset of VirtualizedList props needed to calculate cell metrics\n */\nexport type CellMetricProps = {\n  data: VirtualizedListProps['data'],\n  getItemCount: VirtualizedListProps['getItemCount'],\n  getItem: VirtualizedListProps['getItem'],\n  getItemLayout?: VirtualizedListProps['getItemLayout'],\n  keyExtractor?: VirtualizedListProps['keyExtractor'],\n  ...\n};\n\n/**\n * Provides an interface to query information about the metrics of a list and its cells.\n */\nexport default class ListMetricsAggregator {\n  _averageCellLength = 0;\n  _cellMetrics: Map<string, CellMetrics> = new Map();\n  _contentLength: ?number;\n  _highestMeasuredCellIndex = 0;\n  _measuredCellsLength = 0;\n  _measuredCellsCount = 0;\n  _orientation: ListOrientation = {\n    horizontal: false,\n    rtl: false,\n  };\n\n  /**\n   * Notify the ListMetricsAggregator that a cell has been laid out.\n   *\n   * @returns whether the cell layout has changed since last notification\n   */\n  notifyCellLayout({\n    cellIndex,\n    cellKey,\n    orientation,\n    layout,\n  }: {\n    cellIndex: number,\n    cellKey: string,\n    orientation: ListOrientation,\n    layout: Layout,\n  }): boolean {\n    this._invalidateIfOrientationChanged(orientation);\n\n    const next: CellMetrics = {\n      index: cellIndex,\n      length: this._selectLength(layout),\n      isMounted: true,\n      offset: this.flowRelativeOffset(layout),\n    };\n    const curr = this._cellMetrics.get(cellKey);\n\n    if (!curr || next.offset !== curr.offset || next.length !== curr.length) {\n      if (curr) {\n        const dLength = next.length - curr.length;\n        this._measuredCellsLength += dLength;\n      } else {\n        this._measuredCellsLength += next.length;\n        this._measuredCellsCount += 1;\n      }\n\n      this._averageCellLength =\n        this._measuredCellsLength / this._measuredCellsCount;\n      this._cellMetrics.set(cellKey, next);\n      this._highestMeasuredCellIndex = Math.max(\n        this._highestMeasuredCellIndex,\n        cellIndex,\n      );\n      return true;\n    } else {\n      curr.isMounted = true;\n      return false;\n    }\n  }\n\n  /**\n   * Notify ListMetricsAggregator that a cell has been unmounted.\n   */\n  notifyCellUnmounted(cellKey: string): void {\n    const curr = this._cellMetrics.get(cellKey);\n    if (curr) {\n      curr.isMounted = false;\n    }\n  }\n\n  /**\n   * Notify ListMetricsAggregator that the lists content container has been laid out.\n   */\n  notifyListContentLayout({\n    orientation,\n    layout,\n  }: {\n    orientation: ListOrientation,\n    layout: $ReadOnly<{width: number, height: number}>,\n  }): void {\n    this._invalidateIfOrientationChanged(orientation);\n    this._contentLength = this._selectLength(layout);\n  }\n\n  /**\n   * Return the average length of the cells which have been measured\n   */\n  getAverageCellLength(): number {\n    return this._averageCellLength;\n  }\n\n  /**\n   * Return the highest measured cell index (or 0 if nothing has been measured\n   * yet)\n   */\n  getHighestMeasuredCellIndex(): number {\n    return this._highestMeasuredCellIndex;\n  }\n\n  /**\n   * Returns the exact metrics of a cell if it has already been laid out,\n   * otherwise an estimate based on the average length of previously measured\n   * cells\n   */\n  getCellMetricsApprox(index: number, props: CellMetricProps): CellMetrics {\n    const frame = this.getCellMetrics(index, props);\n    if (frame && frame.index === index) {\n      // check for invalid frames due to row re-ordering\n      return frame;\n    } else {\n      const {data, getItemCount} = props;\n      invariant(\n        index >= 0 && index < getItemCount(data),\n        'Tried to get frame for out of range index ' + index,\n      );\n      return {\n        length: this._averageCellLength,\n        offset: this._averageCellLength * index,\n        index,\n        isMounted: false,\n      };\n    }\n  }\n\n  /**\n   * Returns the exact metrics of a cell if it has already been laid out\n   */\n  getCellMetrics(index: number, props: CellMetricProps): ?CellMetrics {\n    const {data, getItem, getItemCount, getItemLayout} = props;\n    invariant(\n      index >= 0 && index < getItemCount(data),\n      'Tried to get metrics for out of range cell index ' + index,\n    );\n    const keyExtractor = props.keyExtractor ?? defaultKeyExtractor;\n    const frame = this._cellMetrics.get(\n      keyExtractor(getItem(data, index), index),\n    );\n    if (frame && frame.index === index) {\n      return frame;\n    }\n\n    if (getItemLayout) {\n      const {length, offset} = getItemLayout(data, index);\n      // TODO: `isMounted` is used for both \"is exact layout\" and \"has been\n      // unmounted\". Should be refactored.\n      return {index, length, offset, isMounted: true};\n    }\n\n    return null;\n  }\n\n  /**\n   * Gets an approximate offset to an item at a given index. Supports\n   * fractional indices.\n   */\n  getCellOffsetApprox(index: number, props: CellMetricProps): number {\n    if (Number.isInteger(index)) {\n      return this.getCellMetricsApprox(index, props).offset;\n    } else {\n      const frameMetrics = this.getCellMetricsApprox(Math.floor(index), props);\n      const remainder = index - Math.floor(index);\n      return frameMetrics.offset + remainder * frameMetrics.length;\n    }\n  }\n\n  /**\n   * Returns the length of all ScrollView content along the scrolling axis.\n   */\n  getContentLength(): number {\n    return this._contentLength ?? 0;\n  }\n\n  /**\n   * Whether a content length has been observed\n   */\n  hasContentLength(): boolean {\n    return this._contentLength != null;\n  }\n\n  /**\n   * Finds the flow-relative offset (e.g. starting from the left in LTR, but\n   * right in RTL) from a layout box.\n   */\n  flowRelativeOffset(layout: Layout, referenceContentLength?: ?number): number {\n    const {horizontal, rtl} = this._orientation;\n\n    if (horizontal && rtl) {\n      const contentLength = referenceContentLength ?? this._contentLength;\n      invariant(\n        contentLength != null,\n        'ListMetricsAggregator must be notified of list content layout before resolving offsets',\n      );\n      return (\n        contentLength -\n        (this._selectOffset(layout) + this._selectLength(layout))\n      );\n    } else {\n      return this._selectOffset(layout);\n    }\n  }\n\n  /**\n   * Converts a flow-relative offset to a cartesian offset\n   */\n  cartesianOffset(flowRelativeOffset: number): number {\n    const {horizontal, rtl} = this._orientation;\n\n    if (horizontal && rtl) {\n      invariant(\n        this._contentLength != null,\n        'ListMetricsAggregator must be notified of list content layout before resolving offsets',\n      );\n      return this._contentLength - flowRelativeOffset;\n    } else {\n      return flowRelativeOffset;\n    }\n  }\n\n  _invalidateIfOrientationChanged(orientation: ListOrientation): void {\n    if (orientation.rtl !== this._orientation.rtl) {\n      this._cellMetrics.clear();\n    }\n\n    if (orientation.horizontal !== this._orientation.horizontal) {\n      this._averageCellLength = 0;\n      this._highestMeasuredCellIndex = 0;\n      this._measuredCellsLength = 0;\n      this._measuredCellsCount = 0;\n    }\n\n    this._orientation = orientation;\n  }\n\n  _selectLength({\n    width,\n    height,\n  }: $ReadOnly<{width: number, height: number, ...}>): number {\n    return this._orientation.horizontal ? width : height;\n  }\n\n  _selectOffset({x, y}: $ReadOnly<{x: number, y: number, ...}>): number {\n    return this._orientation.horizontal ? x : y;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}